---
globs: "src/**/*.ts"
description: Reusable building blocks, domain primitives, systems primitives, and architecture principles
---

# Reusable Building Blocks & Best Principles

Before implementing changes, identify and reuse existing building blocks:

## Domain Primitives (Always Reuse) {#domain-primitives}

**Core Value Objects** (from `src/lib/domain/valueObjects/`):
- **Identifier**: Use `Identifier.generate<T>()` or `Identifier.from<T>()` for all entity IDs
  - Type aliases: `OrganizationId`, `TaskInstanceId`, `AgentId`, `TaskArchetypeId`, etc.
- **Timestamp**: Use `Timestamp.now()` or `Timestamp.from()` for time values
  - Domain systems receive timestamps as parameters (never call `Date.now()`)
- **Duration**: Use `Duration.ofMinutes()`, `Duration.ofHours()`, `Duration.ofSeconds()` for time spans
- **ResourceBundle**: Use `ResourceBundle.fromArray()` or `ResourceBundle.empty()` for resource collections
- **ResourceUnit**: Use `new ResourceUnit(type, amount)` for individual resources
- **NumericStatMap**: Use for stat collections (ability mods, etc.)

**Design Rule**: Always use `.value` property when using value objects as Map/Set keys (JavaScript uses reference equality, not value equality).

## Systems Primitives (Compose, Don't Duplicate) {#systems-primitives}

**Entity Pattern** (from `docs/current/08-systems-primitives-spec.md`):
- All entities have: `id`, `type`, `attributes`, `tags`, `state`, `timers`, `metadata`
- Core systems reason over `type`, `attributes`, `tags`, `state` - never special-case specific IDs
- Use existing entity patterns: `Organization`, `TaskInstance`, `AgentInstance`, `TaskArchetype`, `FacilityInstance`, `ProgressTrack`

**Systems Primitives Vocabulary**:
- **Entities**: Typed things with identity (`Adventurer`, `Mission`, `Facility`)
- **Attributes**: Capabilities, stats, configuration (read-only during actions)
- **Tags**: Lightweight labels for classification/synergy (`["wilderness", "divine"]`)
- **State**: Finite state machine label (`Idle`, `OnMission`, `InProgress`, `Completed`)
- **Timers**: Time-related fields (`startedAt`, `endsAt`, `cooldownUntil`)
- **Resources**: Quantities (`gold`, `xp`, `fame`) - use ResourceBundle/ResourceUnit
- **Requirements**: Predicates/checks (pure functions, no side effects)
- **Actions**: Verbs (`StartMission`, `ResolveMission`, `UpgradeFacility`)
- **Effects**: State/resource changes (data describing mutations)
- **Events**: Notifications (`MissionStarted`, `MissionCompleted`)

**Core Entities** (from `src/lib/domain/entities/`):
- **Adventurer**: Core adventurer entity with attributes and state
- **Mission**: Mission execution instances with duration and rewards
- **Facility**: Facility entities with bonuses and effects

**Entity Pattern Rules**:
- Constructor-based initialization (not `Partial<T>` spreads)
- Validation in constructors (throw errors for invalid state)
- Immutable value objects in entity properties
- Public readonly for identity, mutable for state that changes

**Core Systems** (from `src/lib/domain/systems/`):
- **MissionDurationModifiers**: Mission duration calculation (pure function, no side effects)
- **CraftingSystem**: Crafting queue processing
- **SlotGenerationSystem**: Slot generation logic

**System Pattern Rules**:
- Pure functions: given inputs, produce outputs (no side effects)
- No dependencies on infrastructure (bus, UI, etc.)
- Deterministic: same inputs = same outputs
- Time passed as parameters (never call `Date.now()`)

## Pattern Reuse Checklist

Before creating new code:
- [ ] Check if domain primitive exists before creating new value object
- [ ] Verify existing entity pattern before creating new entity class
- [ ] Identify existing system before creating new business logic
- [ ] Use existing repository pattern before creating new data access
- [ ] Follow established application service pattern for orchestration
- [ ] Compose from existing building blocks rather than duplicating
- [ ] Verify solution uses systems primitives vocabulary (Entities → Attributes → Tags → State/Timers → Resources → Requirements → Actions → Effects → Events)

## Architecture Principles

- **Domain Purity**: Domain entities/systems must not depend on infrastructure (bus, UI, etc.)
- **Value Object Immutability**: All value objects must be immutable
- **Entity Validation**: All entities must validate state in constructors
- **System Purity**: Systems must be pure functions (no side effects)
- **Repository Abstraction**: Data access through interfaces, not direct Prisma
- **Composition over Duplication**: Compose from primitives rather than creating duplicates
- **Systems Primitives First**: Express new features using existing primitives vocabulary

## Breaking Changes & Modernization Philosophy {#breaking-changes}

**CRITICAL**: This is a solo project. Breaking changes and large-scale refactors are **actively encouraged** to keep the codebase modern and maintainable.

**Breaking Changes Are Welcome**:
- ✅ **DO**: Make breaking changes without hesitation
- ✅ **DO**: Refactor entire subsystems to use modern patterns
- ✅ **DO**: Update dependencies to latest versions (even if breaking)
- ✅ **DO**: Remove deprecated code paths immediately
- ✅ **DO**: Modernize code to use latest TypeScript/SvelteKit features
- ❌ **DON'T**: Maintain backwards compatibility for the sake of it
- ❌ **DON'T**: Keep deprecated code "just in case"
- ❌ **DON'T**: Avoid refactors because they're "too large"
- ❌ **DON'T**: Create compatibility layers or adapters

**Refactoring Priorities**:
1. **Modern Standards First**: Always prefer latest TypeScript, SvelteKit, and framework patterns
2. **Architectural Improvements**: Large refactors that improve architecture are welcome
3. **Code Quality**: Breaking changes that improve code quality are encouraged
4. **Pattern Modernization**: Replace old patterns with modern best practices

**When Modernizing**:
- Break everything: Don't try to maintain compatibility
- Fix everything: Update all affected code to work with new patterns
- Remove deprecated code entirely (do not mark as deprecated)
- Update all usages in single pass (do not create adapters)
