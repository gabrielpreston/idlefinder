---
globs: "src/**/*.test.ts,src/**/*.spec.ts,src/testing/**/*.ts"
description: Testing patterns and requirements for domain-driven idle game development
---

# Solo Testing Strategy

## Test Categories for Solo Development

### Simplified Test Structure

```
src/lib/
├── domain/
│   ├── entities/
│   │   ├── Organization.ts
│   │   ├── Organization.test.ts
│   │   ├── TaskInstance.ts
│   │   └── TaskInstance.test.ts
│   ├── systems/
│   │   ├── TaskResolutionSystem.ts
│   │   ├── TaskResolutionSystem.test.ts
│   │   ├── EconomySystem.ts
│   │   └── EconomySystem.test.ts
│   └── valueObjects/
│       ├── ResourceBundle.ts
│       └── ResourceBundle.test.ts
├── app/
│   ├── StartTaskService.ts
│   └── StartTaskService.test.ts
└── repos/
    ├── contracts/
    └── prisma/
        ├── PrismaTaskRepository.ts
        └── PrismaTaskRepository.test.ts
```

### Test Categories (Simplified)

- **Unit Tests**: Fast, isolated tests of domain entities, value objects, and systems (`*.test.ts` alongside source files)
- **Integration Tests**: Tests that verify multiple systems work together
- **Application Service Tests**: Tests for use-case orchestration with mocked repositories
- **Repository Tests**: Tests for Prisma implementations (can use in-memory or test database)

### Industry Testing Standards

See `.cursor/rules/default-development-workflow.mdc` for industry standards integration.

**Key principles**: Test Pyramid (70/20/8/2), Deterministic Testing, Isolation, Mocking

## Unit Testing Patterns

### Domain Entity Tests

**Pattern**: Test entity methods with focused test cases.

```typescript
describe('Organization', () => {
  it('canAfford checks resources', () => {
    const org = createTestOrg({ wallet: gold(100) });
    expect(org.canAfford(gold(50))).toBe(true);
    expect(org.canAfford(gold(150))).toBe(false);
  });

  it('advanceTo updates timestamps', () => {
    const org = createTestOrg();
    const newTime = Timestamp.now().add(Duration.ofMinutes(10));
    org.advanceTo(newTime);
    expect(org.lastSimulatedAt.value).toBe(newTime.value);
  });

  it('advanceTo throws for past timestamps', () => {
    const org = createTestOrg();
    const pastTime = Timestamp.now().subtract(Duration.ofMinutes(10));
    expect(() => org.advanceTo(pastTime)).toThrow();
  });
});
```

### Domain System Tests

**Pattern**: Test pure functions with deterministic inputs/outputs.

```typescript
describe('TaskResolutionSystem', () => {
  it('resolves ready tasks', () => {
    const system = new TaskResolutionSystem();
    const task = createReadyTask();
    const results = system.resolveTasks([task], agents, archetypes, [], now);
    expect(results).toHaveLength(1);
    expect(results[0].outcomeCategory).toBeDefined();
  });

  it('does not resolve unready tasks', () => {
    const system = new TaskResolutionSystem();
    const task = createUnreadyTask();
    const results = system.resolveTasks([task], new Map(), new Map(), [], now);
    expect(results).toHaveLength(0);
  });

  it('produces deterministic results', () => {
    const system = new TaskResolutionSystem();
    const inputs = createTestInputs();
    const results1 = system.resolveTasks(...inputs);
    const results2 = system.resolveTasks(...inputs);
    expect(results1).toEqual(results2);
  });
});
```

### Value Object Tests

**Pattern**: Test immutable operations.

```typescript
describe('ResourceBundle', () => {
  it('add combines resources', () => {
    const bundle1 = new ResourceBundle([gold(10), wood(5)]);
    const bundle2 = new ResourceBundle([gold(5), stone(3)]);
    const result = bundle1.add(bundle2);
    expect(result.get('gold')).toBe(15);
  });

  it('subtract removes resources', () => {
    const bundle1 = new ResourceBundle([gold(10)]);
    const bundle2 = new ResourceBundle([gold(3)]);
    expect(bundle1.subtract(bundle2).get('gold')).toBe(7);
  });

  it('subtract throws when insufficient', () => {
    const bundle1 = new ResourceBundle([gold(10)]);
    const bundle2 = new ResourceBundle([gold(15)]);
    expect(() => bundle1.subtract(bundle2)).toThrow();
  });
});
```

## Application Service Tests

### Service Tests with Mocked Repositories

**Pattern**: Mock repositories, test use-case orchestration.

```typescript
describe('StartTaskService', () => {
  it('successfully starts a task', async () => {
    const mocks = createMockRepositories();
    const service = new StartTaskService(mocks.org, mocks.task, mocks.agent, economySystem);
    vi.mocked(mocks.task.getOfferById).mockResolvedValue(createTestOffer());
    const result = await service.execute(orgId, offerId, [agentId]);
    expect(result.success).toBe(true);
    expect(mocks.task.saveInstance).toHaveBeenCalled();
  });

  it('fails when offer is already taken', async () => {
    const mocks = createMockRepositories();
    const service = new StartTaskService(mocks.org, mocks.task, mocks.agent, economySystem);
    vi.mocked(mocks.task.getOfferById).mockResolvedValue(createTakenOffer());
    const result = await service.execute(orgId, offerId, [agentId]);
    expect(result.success).toBe(false);
  });
});
```

## Repository Tests

### Prisma Repository Tests

**Pattern**: Test data access with test database.

```typescript
describe('PrismaTaskRepository', () => {
  it('saves and retrieves task instance', async () => {
    const task = createTestTask();
    await repository.saveInstance(task);
    const retrieved = await repository.getInstanceById(task.id);
    expect(retrieved?.id).toEqual(task.id);
    expect(retrieved?.status).toBe('IN_PROGRESS');
  });

  it('finds pending tasks ready for resolution', async () => {
    const readyTask = createReadyTask();
    const unreadyTask = createUnreadyTask();
    await repository.saveInstance(readyTask);
    await repository.saveInstance(unreadyTask);
    const ready = await repository.findPendingTasksReadyForResolution(now);
    expect(ready).toHaveLength(1);
    expect(ready[0].id).toEqual(readyTask.id);
  });
});
```

## Integration Testing Patterns

### System Integration Tests

**Pattern**: Test multiple systems working together.

```typescript
describe('Task Resolution Integration', () => {
  it('integrates task resolution with economy and progression', () => {
    const systems = createTestSystems();
    const org = createTestOrg();
    const task = createTestTask();

    const results = systems.taskResolution.resolveTasks([task], agents, archetypes, [], now);
    for (const result of results) {
      systems.economy.applyReward(org, result.rewards);
      systems.progression.applyTrackChanges(org, result.trackChanges);
    }

    expect(org.economyState.wallet.get('gold')).toBeGreaterThan(0);
    expect(org.progressTracks.get('prestige')?.currentValue).toBeGreaterThan(0);
  });
});
```

## Deterministic Testing Patterns

### Pure Function Testing

**Pattern**: Test determinism of pure functions.

```typescript
describe('TaskResolutionSystem Determinism', () => {
  it('produces identical results for identical inputs', () => {
    const system = new TaskResolutionSystem();
    const inputs = createTestInputs();
    expect(system.resolveTasks(...inputs)).toEqual(system.resolveTasks(...inputs));
  });

  it('produces different results for different inputs', () => {
    const system = new TaskResolutionSystem();
    const inputs1 = createTestInputs();
    const inputs2 = createTestInputsWithDifferentAgents();
    expect(system.resolveTasks(...inputs1)).not.toEqual(system.resolveTasks(...inputs2));
  });
});
```

## Test Configuration

### Vitest Configuration

**Pattern**: Node environment for domain tests, coverage configuration.

```typescript
export default defineConfig({
  test: {
    globals: true,
    environment: 'node',
    coverage: {
      provider: 'v8',
      exclude: ['node_modules/', 'dist/', '**/*.test.ts', 'src/routes/', 'prisma/']
    }
  }
});
```

### Test Execution Commands

See `.cursor/rules/default-development-workflow.mdc#npm-script-reference` for complete npm script reference.

Key commands:
- `npm test` - Run all tests
- `npm test -- --watch` - Watch mode
- `npm test -- --coverage` - Coverage report

## Solo Testing Quality Gates

### Coverage Requirements (Simplified)

- **Domain Entities**: Basic functionality works (canAfford, advanceTo, etc.)
- **Domain Systems**: Pure functions produce correct results
- **Value Objects**: Immutable operations work correctly
- **Application Services**: Use cases orchestrate correctly
- **Repositories**: Data access works correctly

### Performance Requirements (Relaxed)

- **Unit Tests**: < 1 second per test
- **Integration Tests**: < 5 seconds per test
- **Application Service Tests**: < 2 seconds per test
- **Repository Tests**: < 3 seconds per test

### Quality Standards (Solo)

- **Test Isolation**: Tests don't depend on each other
- **Deterministic**: Domain system tests produce consistent results
- **Fast Feedback**: Quick test execution for development
- **Essential Coverage**: Critical paths covered
- **Maintainable**: Tests are easy to understand and modify

### Industry Standards Integration

See `.cursor/rules/default-development-workflow.mdc` for industry standards integration.

**Checklist**: Domain entity tests, system tests (deterministic), value object tests, application service tests (with mocks), repository tests, integration tests

## Action Testing Patterns

### Behavioral Testing Principles

**Core Principle**: Test observable behavior through public APIs, not internal structure

**Guidelines**:
- ✅ **DO**: Apply effects and verify outcomes through public APIs
- ✅ **DO**: Test observable behavior, not internal structure
- ✅ **DO**: Use `applyEffects()` to verify effect behavior
- ✅ **DO**: Verify through events when testing `generateEvents()`
- ❌ **DON'T**: Access private fields (`resourceUnits`, `entityId`, etc.)
- ❌ **DON'T**: Access private action state (`(action as any).outcome`)
- ❌ **DON'T**: Test structure without verifying behavior

### Standard Test Structure

Follow this 4-step pattern for Action tests:

1. **Setup**: Create entities and context
2. **Execute**: Call `computeEffects()` or `generateEvents()`
3. **Apply & Verify**: Use `applyEffects()` and check outcomes
4. **Cleanup**: Restore mocks

**Example**:

```typescript
it('includes fame in rewards when fame > 0', () => {
  // 1. Setup
  const entities = createTestEntities();
  const context = createTestContext(entities);
  const mockRandom = vi.spyOn(Math, 'random').mockReturnValue(0.75);
  
  try {
    // 2. Execute
    const action = new ResolveMissionAction('mission-1');
    const effects = action.computeEffects(context, {});
    
    // 3. Apply & Verify
    const result = applyEffects(effects, entities, initialResources);
    expect(result.resources.get('fame')).toBeGreaterThan(0);
    expect(result.resources.get('gold')).toBeGreaterThan(0);
  } finally {
    // 4. Cleanup
    mockRandom.mockRestore();
  }
});
```

### Test Helper Usage

Use helper functions from `actionTestHelpers` for common patterns:

**Resource Verification**:

```typescript
import { expectResourceChange } from '../../test-utils/actionTestHelpers';

expectResourceChange(effects, initialResources, entities, {
  gold: { min: 100 },
  fame: { exact: 5 },
  materials: { max: 10 }
});
```

**Entity State Verification**:

```typescript
import { expectEntityStateChange } from '../../test-utils/actionTestHelpers';

expectEntityStateChange(effects, entities, 'entity-id', {
  state: 'Completed',
  attributePath: 'attributes.xp',
  attributeValue: 100
});
```

**Entity Creation Verification**:

```typescript
import { expectEntityCreated } from '../../test-utils/actionTestHelpers';

const { result, created } = expectEntityCreated(effects, entities, 'Item', {
  count: 1,
  predicate: (item) => item.attributes.itemType === 'weapon'
});
```

### Anti-Patterns

**❌ BAD: Private Field Access**

```typescript
// Don't access private fields
const resourceEffect = effects.find(e => e instanceof ModifyResourceEffect);
const fameUnit = resourceEffect.resourceUnits.find(u => u.type === 'fame'); // ❌
```

**✅ GOOD: Behavioral Verification**

```typescript
// Apply effects and verify through public API
const result = applyEffects(effects, entities, new ResourceBundle(new Map()));
expect(result.resources.get('fame')).toBeGreaterThan(0); // ✅
```

**❌ BAD: Private State Access**

```typescript
// Don't access private action state
expect((action as any).outcome).toBe('CriticalSuccess'); // ❌
```

**✅ GOOD: Verify Through Events**

```typescript
// Verify through events (public API)
const events = action.generateEvents(entities, resources, effects, {});
const payload = events[0].payload as { outcome: string };
expect(payload.outcome).toBe('CriticalSuccess'); // ✅
```

**❌ BAD: Structure Testing**

```typescript
// Don't just check structure
expect(effects.length).toBeGreaterThan(0); // ❌
expect(effects[0]).toBeInstanceOf(ModifyResourceEffect); // ❌
```

**✅ GOOD: Behavior Verification**

```typescript
// Verify effect actually works
const result = applyEffects(effects, entities, initialResources);
expect(result.resources.get('gold')).toBeGreaterThan(0); // ✅
```

### References

- Good behavioral examples: `src/lib/domain/primitives/Effect.test.ts:30-50`
- Helper utilities: `src/lib/test-utils/actionTestHelpers.ts`
- Effect application: `src/lib/domain/primitives/Effect.ts:489-507`
